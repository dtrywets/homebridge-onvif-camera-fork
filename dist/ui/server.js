import{HomebridgePluginUiServer as j,RequestError as u}from"@homebridge/plugin-ui-utils";import{Cam as O}from"onvif/promises/index.js";import{z as o}from"zod";var g=o.object({hostname:o.string().min(1),port:o.number().min(1).max(65535),username:o.string().min(1),password:o.string(),timeout:o.number().positive().optional().default(5e3)}),k=o.object({enableMotion:o.boolean().optional().default(!0),motionTimeout:o.number().positive().optional().default(1e3),enableAudio:o.boolean().optional().default(!0),enableTwoWayAudio:o.boolean().optional().default(!1)}),I=o.object({manufacturer:o.string().default("homebridge-onvif-camera"),firmware:o.string().default("0.0.1"),model:o.string().default("homebridge-onvif-camera"),serialNumber:o.string().default("0.0.1")}),G=o.object({name:o.string().min(1),profile:o.string().min(1),connection:g,feature:k,information:I}),q=o.object({name:o.string().min(1).optional().default("ONVIF Camera"),platform:o.string().min(1),cameras:G.array(),ffmpegPath:o.string().min(1).optional().default("ffmpeg")});import{ZodError as A}from"zod";var C=r=>r instanceof A?r.errors.map(t=>`${t.path.join(".")}: ${t.message}`).join(`
`):r instanceof Error?r.message:r instanceof Object?JSON.stringify(r):"Unknown error occurred";import{spawn as U}from"child_process";import{EventEmitter as L}from"events";var E=["-hide_banner","-y","-loglevel","level+info","-flush_packets","1"],M=["-c:v","libx264","-c:a","aac","-pix_fmt","yuv420p","-tune","zerolatency","-preset","ultrafast"],_=["-crf","15","-f","hls","-hls_time","2","-hls_init_time","1","-hls_list_size","3","-hls_flags","delete_segments+omit_endlist","-force_key_frames","expr:gte(t,n_forced*2)","-vf","scale='min(1920,iw):-2',scale='-2:min(1080,ih)'",...M],Q=[...M,"-an","-sn","-dn"],R=["-vframes","1","-f","mjpeg","-"],d="media.m3u8";import V from"node:path";var b=class extends L{cmd;child;options;constructor(t,e){super(),this.options=structuredClone(t),this.cmd=e??"ffmpeg"}start(){let t=this.getExecArguments();this.child=U(this.cmd,t),this.child.on("exit",(e,i)=>{this.emit("exit",e,i)}),this.child.on("error",e=>{this.emit("error",e)}),this.child.stdout.on("data",e=>{this.emit("stdout",e)}),this.child.stderr.on("data",e=>{this.emit("stderr",e)})}stop(){this.child&&(this.child.kill("SIGTERM"),delete this.child),this.emit("stop")}getExecArguments(){return this.options.type==="JPEG"?["-i",this.options.rtspUri,...E,...R]:[...E,"-i",this.options.rtspUri,"-r",this.options.frameRate.toString(),..._,V.join(this.options.outputPath,d)]}};import{randomUUID as z}from"node:crypto";import F from"node:path";import*as f from"node:fs";import $ from"node:os";import c from"node:process";var S=new Set,y=new Set,T=!1,N=!1;async function h(r,t,e){if(T)return;T=!0,S.size>0&&t&&console.error(["SYNCHRONOUS TERMINATION NOTICE:","When explicitly exiting the process via process.exit or via a parent process,","asynchronous tasks in your exitHooks will not run. Either remove these tasks,","use gracefulExit() instead of process.exit(), or ensure your parent process","sends a SIGINT to the process running this code."].join(" "));let i=128+e,m=(s=!1)=>{(s===!0||r===!0)&&c.exit(i)};for(let s of y)s(i);if(t){m();return}let a=[],n=0;for(let[s,w]of S)n=Math.max(n,w),a.push(Promise.resolve(s(i)));let P=setTimeout(()=>{m(!0)},n);await Promise.all(a),clearTimeout(P),m()}function H(r){let{onExit:t,wait:e,isSynchronous:i}=r,m=[t,e];return i?y.add(t):S.add(m),N||(N=!0,c.once("beforeExit",h.bind(void 0,!0,!1,-128)),c.once("SIGINT",h.bind(void 0,!0,!1,2)),c.once("SIGTERM",h.bind(void 0,!0,!1,15)),c.once("exit",h.bind(void 0,!1,!0,0)),c.on("message",a=>{a==="shutdown"&&h(!0,!0,-128)})),()=>{i?y.delete(t):S.delete(m)}}function x(r){if(typeof r!="function")throw new TypeError("onExit must be a function");return H({onExit:r,isSynchronous:!0})}var v=class extends j{hlsOutputPath;ffmpegProcess;constructor(){super();try{console.log(this.homebridgeStoragePath),this.hlsOutputPath=f.mkdtempSync(F.join(this.homebridgeStoragePath??$.tmpdir(),"homebridge-onvif-camera-")),this.onRequest("/camera/metadata",this.handleFetchCameraMetadata.bind(this)),this.onRequest("/camera/video",this.handleStreamVideo.bind(this)),this.onRequest("/camera/video/file",this.handleFetchVideoFile.bind(this)),this.onRequest("/camera/video/stop",this.handleStopVideo.bind(this))}catch(t){this.hlsOutputPath="",console.error("Failed to init api server",t)}console.log(this.hlsOutputPath),this.ready()}async handleFetchCameraMetadata(t){try{let e=g.parse(t),i=new O({...e});await i.connect();let m=(await i.getProfiles()).map(n=>({name:n.name,token:n.$.token,video:{encoding:n.videoEncoderConfiguration.encoding,width:n.videoEncoderConfiguration.resolution.width,height:n.videoEncoderConfiguration.resolution.height,bitrateLimit:n.videoEncoderConfiguration.rateControl.bitrateLimit,frameRateLimit:n.videoEncoderConfiguration.rateControl.frameRateLimit}})),a=await i.getDeviceInformation();return{profiles:m,information:{manufacturer:a.manufacturer??"",model:a.model??"",firmware:a.firmwareVersion??"",serialNumber:a.serialNumber??""}}}catch(e){throw new u(C(e),e)}}async handleStreamVideo(t){try{let e=g.parse(t.connectionConfig),i=new O(e);await i.connect();let m=(await i.getStreamUri({protocol:"RTSP",profileToken:t.profile})).uri,a=(await i.getProfiles()).find(s=>s.$.token===t.profile);if(a===void 0)throw new u("Profile does not exist",void 0);this.ffmpegProcess!==void 0&&this.ffmpegProcess.stop();let n=z(),P=m.replace("://",`://${e.username}:${e.password}@`);this.ffmpegProcess=new b({type:"HLS",rtspUri:P,frameRate:a.videoEncoderConfiguration.rateControl.frameRateLimit,outputPath:this.hlsOutputPath}),this.ffmpegProcess.on("data",s=>{this.pushEvent(n,s.toString("base64"))}),this.ffmpegProcess.start();for(let s=0;s<20;s++)if(await new Promise(w=>setTimeout(w,1e3)),f.existsSync(F.join(this.hlsOutputPath,d)))return{playlist:d};throw this.ffmpegProcess.stop(),new u("FFmpeg timeout",void 0)}catch(e){throw e instanceof u?e:new u(C(e),e)}}async handleFetchVideoFile(t){try{let e=f.readFileSync(F.join(this.hlsOutputPath,t.filename));return t.range!==void 0?{base64Data:e.subarray(t.range.start,t.range.end).toString("base64")}:{base64Data:e.toString("base64")}}catch(e){throw new u(C(e),e)}}async handleStopVideo(){this.ffmpegProcess?.stop()}destroy(){this.hlsOutputPath!==""&&f.rmSync(this.hlsOutputPath,{force:!0,recursive:!0}),this.ffmpegProcess?.stop()}},D=new v;x(()=>{D.destroy()});
